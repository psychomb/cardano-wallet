-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Core integration test library.
--   
--   Shared core functionality for our integration test suites.
@package cardano-wallet-core-integration
@version 2019.6.24

module Cardano.Wallet.TransactionSpecShared
propMaxNumberOfInputsEstimation :: TransactionLayer t key -> Quantity "byte" Word16 -> Quantity "byte" Word16 -> Word8 -> Word8 -> Property
instance Test.QuickCheck.Arbitrary.Arbitrary (Data.Quantity.Quantity "byte" GHC.Word.Word16)

module Test.Integration.Faucet

-- | An opaque <a>Faucet</a> type from which one can get a wallet with
--   funds
data Faucet
Faucet :: MVar [Mnemonic 15] -> MVar [Mnemonic 12] -> MVar [(Address, Coin) -> IO ByteString] -> Faucet
[sequential] :: Faucet -> MVar [Mnemonic 15]
[random] :: Faucet -> MVar [Mnemonic 12]
[txBuilder] :: Faucet -> MVar [(Address, Coin) -> IO ByteString]
nextWallet :: NextWallet scheme => Faucet -> IO (Mnemonic (MnemonicSize scheme))

-- | Get a raw transaction builder. It constructs and sign a transaction
--   via an private key that is owned "externally". Returns a bytes string
--   ready to be sent to a node.
nextTxBuilder :: Faucet -> IO ((Address, Coin) -> IO ByteString)
instance Test.Integration.Faucet.NextWallet "seq"
instance Test.Integration.Faucet.NextWallet "rnd"

module Test.Integration.Framework.Request

-- | Makes a request to the API and decodes the response.
request :: forall a m s. (FromJSON a, MonadIO m, MonadCatch m, HasType (Text, Manager) s) => s -> (Method, Text) -> Headers -> Payload -> m (Status, Either RequestException a)

-- | Makes a request to the API, but throws if it fails.
unsafeRequest :: forall a m t. (FromJSON a, MonadIO m, MonadCatch m) => Context t -> (Method, Text) -> Payload -> m (Status, a)

-- | The headers of the request
data Headers
Headers :: RequestHeaders -> Headers
Default :: Headers
None :: Headers

-- | The payload of the request
data Payload
Json :: Value -> Payload
NonJson :: ByteString -> Payload
Empty :: Payload

-- | The result when <a>request</a> fails.
data RequestException

-- | JSON decoding the given response data failed.
DecodeFailure :: ByteString -> RequestException

-- | The HTTP response status code indicated failure.
ClientError :: Value -> RequestException

-- | A wild exception upon sending the request
HttpException :: HttpExceptionContent -> RequestException

-- | Running Context for our integration test
data Context t
Context :: IO () -> (Text, Manager) -> Port "node" -> Port "wallet" -> Faucet -> (TxDescription -> (Natural, Natural)) -> Proxy t -> Context t

-- | Cleanup action for the context
[_cleanup] :: Context t -> IO ()

-- | The underlying BaseUrl and Manager used by the Wallet Client
[_manager] :: Context t -> (Text, Manager)

-- | Node TCP port
[_nodePort] :: Context t -> Port "node"

-- | Server TCP port
[_walletPort] :: Context t -> Port "wallet"

-- | A <a>Faucet</a> handle in to have access to funded wallets in
--   integration tests.
[_faucet] :: Context t -> Faucet

-- | A fee estimator for the integration tests
[_feeEstimator] :: Context t -> TxDescription -> (Natural, Natural)
[_target] :: Context t -> Proxy t

-- | Describe a transaction in terms of its inputs and outputs
data TxDescription
TxDescription :: Int -> Int -> TxDescription
[nInputs] :: TxDescription -> Int
[nOutputs] :: TxDescription -> Int
instance GHC.Show.Show Test.Integration.Framework.Request.Headers
instance GHC.Show.Show Test.Integration.Framework.Request.Payload
instance GHC.Show.Show Test.Integration.Framework.Request.RequestException
instance GHC.Generics.Generic (Test.Integration.Framework.Request.Context t)
instance GHC.Show.Show Test.Integration.Framework.Request.TxDescription
instance GHC.Exception.Type.Exception Test.Integration.Framework.Request.RequestException

module Test.Integration.Framework.DSL

-- | Running Context for our integration test
data Context t
Context :: IO () -> (Text, Manager) -> Port "node" -> Port "wallet" -> Faucet -> (TxDescription -> (Natural, Natural)) -> Proxy t -> Context t

-- | Cleanup action for the context
[_cleanup] :: Context t -> IO ()

-- | The underlying BaseUrl and Manager used by the Wallet Client
[_manager] :: Context t -> (Text, Manager)

-- | Node TCP port
[_nodePort] :: Context t -> Port "node"

-- | Server TCP port
[_walletPort] :: Context t -> Port "wallet"

-- | A <a>Faucet</a> handle in to have access to funded wallets in
--   integration tests.
[_faucet] :: Context t -> Faucet

-- | A fee estimator for the integration tests
[_feeEstimator] :: Context t -> TxDescription -> (Natural, Natural)
[_target] :: Context t -> Proxy t

-- | A class to select the right command for a given 'Context t'
class KnownCommand t
commandName :: KnownCommand t => String

-- | Describe a transaction in terms of its inputs and outputs
data TxDescription
TxDescription :: Int -> Int -> TxDescription
[nInputs] :: TxDescription -> Int
[nOutputs] :: TxDescription -> Int

-- | Makes a request to the API and decodes the response.
request :: forall a m s. (FromJSON a, MonadIO m, MonadCatch m, HasType (Text, Manager) s) => s -> (Method, Text) -> Headers -> Payload -> m (Status, Either RequestException a)

-- | Makes a request to the API, but throws if it fails.
unsafeRequest :: forall a m t. (FromJSON a, MonadIO m, MonadCatch m) => Context t -> (Method, Text) -> Payload -> m (Status, a)

-- | A file is eventually created on the given location
expectPathEventuallyExist :: FilePath -> IO ()

-- | Expect a successful response, without any further assumptions.
expectSuccess :: (MonadIO m, MonadFail m) => (s, Either RequestException a) -> m ()

-- | Expect an error response, without any further assumptions.
expectError :: (MonadIO m, MonadFail m, Show a) => (s, Either RequestException a) -> m ()

-- | Expect an error response, without any further assumptions.
expectErrorMessage :: (MonadIO m, MonadFail m, Show a) => String -> (s, Either RequestException a) -> m ()
expectFieldEqual :: (MonadIO m, MonadFail m, Show a, Eq a) => Lens' s a -> a -> (Status, Either RequestException s) -> m ()
expectFieldNotEqual :: (MonadIO m, MonadFail m, Show a, Eq a) => Lens' s a -> a -> (Status, Either RequestException s) -> m ()
expectFieldSatisfy :: (MonadIO m, MonadFail m, Show a) => Lens' s a -> (a -> Bool) -> (Status, Either RequestException s) -> m ()
expectFieldBetween :: (MonadIO m, MonadFail m, Show a, Ord a) => Lens' s a -> (a, a) -> (Status, Either RequestException s) -> m ()
expectListItemFieldBetween :: (MonadIO m, MonadFail m, Show a, Eq a, Ord a) => Int -> Lens' s a -> (a, a) -> (Status, Either RequestException [s]) -> m ()

-- | Expects that returned data list's particular item field matches the
--   expected value. e.g. expectListItemFieldEqual 0 walletName "first"
--   response expectListItemFieldEqual 1 walletName "second" response
expectListItemFieldEqual :: (MonadIO m, MonadFail m, Show a, Eq a) => Int -> Lens' s a -> a -> (Status, Either RequestException [s]) -> m ()
expectListItemFieldSatisfy :: (MonadIO m, MonadFail m, Show a) => Int -> Lens' s a -> (a -> Bool) -> (Status, Either RequestException [s]) -> m ()

-- | Expects data list returned by the API to be of certain length
expectListSizeEqual :: (MonadIO m, MonadFail m, Foldable xs) => Int -> (Status, Either RequestException (xs a)) -> m ()

-- | Expect a given response code on the response.
expectResponseCode :: MonadIO m => Status -> (Status, a) -> m ()

-- | Expects wallet from the request to eventually reach the given state or
--   beyond.
expectEventually :: forall ctx s a m. (MonadIO m, MonadCatch m, MonadFail m) => (Ord a, Show a, FromJSON s) => HasType (Text, Manager) ctx => ctx -> (s -> (Method, Text)) -> Lens' s a -> a -> (Status, Either RequestException s) -> m ()

-- | Same as <a>expectEventually</a>, but works directly on
--   <a>ApiWallet</a> rather than on a response from the API.
expectEventually' :: forall ctx s a m. (MonadIO m, MonadCatch m, MonadFail m) => (Ord a, Show a, FromJSON s) => HasType (Text, Manager) ctx => ctx -> (s -> (Method, Text)) -> Lens' s a -> a -> s -> m ()

-- | Expects a given string to be a valid JSON output corresponding to some
--   given data-type <tt>a</tt>. Returns this type if successful.
expectValidJSON :: forall m a. (MonadFail m, FromJSON a) => Proxy a -> String -> m a
expectCliFieldBetween :: (MonadIO m, MonadFail m, Show a, Ord a) => Lens' s a -> (a, a) -> s -> m ()
expectCliFieldEqual :: (MonadIO m, Show a, Eq a) => Lens' s a -> a -> s -> m ()
expectCliFieldNotEqual :: (MonadIO m, Show a, Eq a) => Lens' s a -> a -> s -> m ()
expectCliListItemFieldBetween :: (MonadIO m, MonadFail m, Show a, Eq a, Ord a) => Int -> Lens' s a -> (a, a) -> [s] -> m ()

-- | Same as <a>expectListItemFieldEqual</a> but for CLI
expectCliListItemFieldEqual :: (MonadIO m, MonadFail m, Show a, Eq a) => Int -> Lens' s a -> a -> [s] -> m ()

-- | Expects wallet UTxO statistics from the request to be equal to
--   pre-calculated statistics.
expectWalletUTxO :: (MonadIO m, MonadFail m) => [Word64] -> Either RequestException ApiUtxoStatistics -> m ()

-- | Apply <tt>a</tt> to all actions in sequence
verify :: Monad m => a -> [a -> m ()] -> m ()

-- | The headers of the request
data Headers
Headers :: RequestHeaders -> Headers
Default :: Headers
None :: Headers

-- | The payload of the request
data Payload
Json :: Value -> Payload
NonJson :: ByteString -> Payload
Empty :: Payload

-- | The result when <a>request</a> fails.
data RequestException

-- | JSON decoding the given response data failed.
DecodeFailure :: ByteString -> RequestException

-- | The HTTP response status code indicated failure.
ClientError :: Value -> RequestException

-- | A wild exception upon sending the request
HttpException :: HttpExceptionContent -> RequestException
addressPoolGap :: HasType (ApiT AddressPoolGap) s => Lens' s Int
amount :: HasType (Quantity "lovelace" Natural) s => Lens' s Natural
apparentPerformance :: HasType Double s => Lens' s Double
balanceAvailable :: HasType (ApiT WalletBalance) s => Lens' s Natural
balanceTotal :: HasType (ApiT WalletBalance) s => Lens' s Natural
blocks :: HasField' "producedBlocks" s (Quantity "block" Natural) => Lens' s Natural
delegation :: forall s d. (d ~ WalletDelegation (ApiT PoolId), HasType (ApiT d) s) => Lens' s (WalletDelegation (ApiT PoolId))
direction :: HasType (ApiT Direction) s => Lens' s Direction
feeEstimator :: Lens' (Context t) (TxDescription -> (Natural, Natural))
inputs :: HasType [ApiTxInput t] s => Lens' s [ApiTxInput t]
metrics :: HasType ApiStakePoolMetrics s => Lens' s ApiStakePoolMetrics
outputs :: forall s t a. (a ~ AddressAmount t, HasType (NonEmpty a) s) => Lens' s [a]
passphraseLastUpdate :: forall s i. (i ~ WalletPassphraseInfo, HasType (Maybe (ApiT i)) s) => Lens' s (Maybe Text)
stake :: HasField' "controlledStake" s (Quantity "lovelace" Natural) => Lens' s Natural
state :: HasField' "state" s (ApiT t) => Lens' s t
status :: HasType (ApiT TxStatus) s => Lens' s TxStatus
syncProgress :: HasType (ApiT SyncProgress) s => Lens' s SyncProgress
walletId :: HasType (ApiT WalletId) s => Lens' s Text
walletName :: HasType (ApiT WalletName) s => Lens' s Text
walletReward :: forall s q. (q ~ Quantity "lovelace" Natural, HasType q s) => Lens' s Natural
(</>) :: ToHttpApiData a => Text -> a -> Text
infixr 5 </>

-- | List index (subscript) operator, starting from 0. It is an instance of
--   the more general <a>genericIndex</a>, which takes an index of any
--   integral type.
(!!) :: () => [a] -> Int -> a
infixl 9 !!

-- | Create an empty wallet
emptyByronWallet :: Context t -> IO ApiByronWallet
emptyByronWalletWith :: Context t -> (Text, [Text], Text) -> IO ApiByronWallet

-- | Create an empty wallet
emptyWallet :: Context t -> IO ApiWallet

-- | Create an empty wallet
emptyWalletWith :: Context t -> (Text, Text, Int) -> IO ApiWallet
getFromResponse :: Lens' s a -> (Status, Either RequestException s) -> a
getFromResponseList :: Int -> Lens' s a -> (Status, Either RequestException [s]) -> a
json :: QuasiQuoter
joinStakePool :: forall t w. HasType (ApiT WalletId) w => Context t -> ApiStakePool -> (w, Text) -> IO (Status, Either RequestException (ApiTransaction  'Testnet))
quitStakePool :: forall t w. HasType (ApiT WalletId) w => Context t -> ApiStakePool -> (w, Text) -> IO (Status, Either RequestException (ApiTransaction  'Testnet))
listAddresses :: Context t -> ApiWallet -> IO [ApiAddress  'Testnet]
listTransactions :: Context t -> ApiWallet -> Maybe UTCTime -> Maybe UTCTime -> Maybe SortOrder -> IO [ApiTransaction  'Testnet]
listAllTransactions :: Context t -> ApiWallet -> IO [ApiTransaction  'Testnet]

-- | teardown after each test (currently only deleting all wallets)
tearDown :: Context t -> IO ()
fixtureRawTx :: Context t -> (Address, Natural) -> IO ByteString

-- | Restore a faucet Byron wallet and wait until funds are available.
fixtureByronWallet :: Context t -> IO ApiByronWallet

-- | Restore a faucet and wait until funds are available.
fixtureWallet :: Context t -> IO ApiWallet

-- | Restore a wallet with the given UTxO distribution. Note that there's a
--   limitation to what can be done here. We only have 10 UTxO available in
--   each faucet and they "only" have 'faucetUtxoAmt = 100_000 Ada' in
--   each.
--   
--   This function makes no attempt at ensuring the request is valid, so be
--   careful.
fixtureWalletWith :: Context t -> [Natural] -> IO ApiWallet

-- | Total amount on each faucet wallet
faucetAmt :: Natural

-- | Each faucet wallet is composed of 10 times a single faucet UTxO of
--   100_000 Ada.
faucetUtxoAmt :: Natural
proc' :: FilePath -> [String] -> CreateProcess

-- | Wait for a booting wallet server to start. Wait up to 30s or fail.
waitForServer :: forall t ctx. (HasType (Port "wallet") ctx, KnownCommand t) => ctx -> IO ()

-- | <a>map</a> flipped.
for :: [a] -> (a -> b) -> [b]
toQueryString :: [(Text, Text)] -> Text
utcIso8601ToText :: UTCTime -> Text
eventually :: IO a -> IO a
eventuallyUsingDelay :: Int -> IO a -> IO a
eventually_ :: IO () -> IO ()
eventuallyUsingDelay_ :: Int -> IO () -> IO ()

-- | Default passphrase used for fixture wallets
fixturePassphrase :: Text
postByronWalletEp :: (Method, Text)
migrateByronWalletEp :: forall w n. (HasType (ApiT WalletId) w, HasType (ApiT WalletId) n) => w -> n -> (Method, Text)
calculateByronMigrationCostEp :: forall w. HasType (ApiT WalletId) w => w -> (Method, Text)
getByronWalletEp :: ApiByronWallet -> (Method, Text)
listByronWalletsEp :: (Method, Text)
listByronTxEp :: ApiByronWallet -> Text -> (Method, Text)
deleteByronWalletEp :: ApiByronWallet -> (Method, Text)
deleteByronTxEp :: ApiByronWallet -> ApiTxId -> (Method, Text)
getWalletEp :: ApiWallet -> (Method, Text)
deleteWalletEp :: ApiWallet -> (Method, Text)
getWalletUtxoEp :: ApiWallet -> (Method, Text)
getAddressesEp :: ApiWallet -> Text -> (Method, Text)
listStakePoolsEp :: (Method, Text)
joinStakePoolEp :: forall w. HasType (ApiT WalletId) w => ApiStakePool -> w -> (Method, Text)
quitStakePoolEp :: forall w. HasType (ApiT WalletId) w => ApiStakePool -> w -> (Method, Text)
stakePoolEp :: forall w. HasType (ApiT WalletId) w => Method -> ApiStakePool -> w -> (Method, Text)
postTxEp :: ApiWallet -> (Method, Text)
postExternalTxEp :: (Method, Text)
postTxFeeEp :: ApiWallet -> (Method, Text)
listTxEp :: ApiWallet -> Text -> (Method, Text)
networkInfoEp :: (Method, Text)
updateWalletPassEp :: ApiWallet -> (Method, Text)
listWalletsEp :: (Method, Text)
deleteTxEp :: ApiWallet -> ApiTxId -> (Method, Text)
command :: CmdResult r => [CmdOption] -> String -> [String] -> IO r

-- | Run a command using the 'cardano-wallet' executable for the target
--   <tt>t</tt>.
cardanoWalletCLI :: forall t r. (CmdResult r, KnownCommand t) => [String] -> IO r
generateMnemonicsViaCLI :: forall t r. (CmdResult r, KnownCommand t) => [String] -> IO r
createWalletViaCLI :: forall t s. (HasType (Port "wallet") s, KnownCommand t) => s -> [String] -> String -> String -> String -> IO (ExitCode, String, Text)
deleteWalletViaCLI :: forall t r s. (CmdResult r, KnownCommand t, HasType (Port "wallet") s) => s -> String -> IO r
getWalletUtxoStatisticsViaCLI :: forall t r s. (CmdResult r, KnownCommand t, HasType (Port "wallet") s) => s -> String -> IO r
getWalletViaCLI :: forall t r s. (CmdResult r, KnownCommand t, HasType (Port "wallet") s) => s -> String -> IO r
listAddressesViaCLI :: forall t r s. (CmdResult r, KnownCommand t, HasType (Port "wallet") s) => s -> [String] -> IO r
listStakePoolsViaCLI :: forall t r s. (CmdResult r, KnownCommand t, HasType (Port "wallet") s) => s -> IO r
listWalletsViaCLI :: forall t r s. (CmdResult r, KnownCommand t, HasType (Port "wallet") s) => s -> IO r
updateWalletNameViaCLI :: forall t r s. (CmdResult r, KnownCommand t, HasType (Port "wallet") s) => s -> [String] -> IO r
updateWalletPassphraseViaCLI :: forall t s. (KnownCommand t, HasType (Port "wallet") s) => s -> String -> String -> String -> String -> IO (ExitCode, Text, Text)
postTransactionViaCLI :: forall t s. (HasType (Port "wallet") s, KnownCommand t) => s -> String -> [String] -> IO (ExitCode, String, Text)
postTransactionFeeViaCLI :: forall t s. (HasType (Port "wallet") s, KnownCommand t) => s -> [String] -> IO (ExitCode, String, Text)
listTransactionsViaCLI :: forall t r s. (CmdResult r, HasType (Port "wallet") s, KnownCommand t) => s -> [String] -> IO r
postExternalTransactionViaCLI :: forall t r s. (CmdResult r, HasType (Port "wallet") s, KnownCommand t) => s -> [String] -> IO r
deleteTransactionViaCLI :: forall t r s. (CmdResult r, KnownCommand t, HasType (Port "wallet") s) => s -> String -> String -> IO r

module Test.Integration.Framework.TestData
chineseMnemonics9 :: [Text]
chineseMnemonics18 :: [Text]
frenchMnemonics12 :: [Text]
frenchMnemonics21 :: [Text]
invalidMnemonics12 :: [Text]
invalidMnemonics15 :: [Text]
japaneseMnemonics12 :: [Text]
japaneseMnemonics15 :: [Text]
mnemonics3 :: [Text]
mnemonics6 :: [Text]
mnemonics9 :: [Text]
mnemonics12 :: [Text]
mnemonics15 :: [Text]
mnemonics18 :: [Text]
mnemonics21 :: [Text]
mnemonics24 :: [Text]
specMnemonicByron :: [Text]
specMnemonicSentence :: [Text]
specMnemonicSecondFactor :: [Text]
arabicWalletName :: Text
falseWalletIds :: [(String, String)]
kanjiWalletName :: Text
polishWalletName :: Text
russianWalletName :: Text
wildcardsWalletName :: Text
addressPoolGapMax :: Int
addressPoolGapMin :: Int
cmdOk :: String
versionLine :: Text
passphraseMaxLength :: Int
passphraseMinLength :: Int
payloadWith :: Text -> [Text] -> Payload
simplePayload :: Payload
updateNamePayload :: Text -> Payload
updatePassPayload :: Text -> Text -> Payload
getHeaderCases :: forall a. Show a => Status -> [(String, Headers, [(Status, Either RequestException a) -> IO ()])]
postHeaderCases :: Show a => [(String, Headers, [(Status, Either RequestException a) -> IO ()])]
errMsgWalletIdEncoding :: String
errMsg400StartTimeLaterThanEndTime :: String -> String -> String
errMsg403Fee :: String
errMsg403NotEnoughMoney :: Int -> Int -> String
errMsg403UTxO :: String
errMsg403WrongPass :: String
errMsg403NoPendingAnymore :: Text -> String
errMsg404NoSuchPool :: Text -> String
errMsg403NothingToMigrate :: Text -> String
errMsg404NoEndpoint :: String
errMsg404CannotFindTx :: Text -> String
errMsg404NoRootKey :: Text -> String
errMsg404NoWallet :: Text -> String
errMsg403InputsDepleted :: String
errMsg403TxTooBig :: Int -> String
errMsg400MalformedTxPayload :: String
errMsg400WronglyEncodedTxPayload :: String
errMsg400ParseError :: String
errMsg403ZeroAmtOutput :: String
errMsg405 :: String
errMsg406 :: String
errMsg415 :: String
errMsg415OctetStream :: String
errMsg500 :: String

module Test.Integration.Scenario.API.Addresses
spec :: forall t n. n ~  'Testnet => SpecWith (Context t)

module Test.Integration.Scenario.API.ByronTransactions
spec :: forall t n. n ~  'Testnet => SpecWith (Context t)

module Test.Integration.Scenario.API.ByronWallets
spec :: forall t n. n ~  'Testnet => SpecWith (Context t)

module Test.Integration.Scenario.API.Network
spec :: forall t. SpecWith (Context t)

module Test.Integration.Scenario.API.Transactions
spec :: forall t n. n ~  'Testnet => SpecWith (Context t)

module Test.Integration.Scenario.API.Wallets
spec :: forall t n. n ~  'Testnet => SpecWith (Context t)

module Test.Integration.Scenario.CLI.Addresses
spec :: forall t n. (n ~  'Testnet, KnownCommand t) => SpecWith (Context t)

module Test.Integration.Scenario.CLI.Miscellaneous
spec :: forall t. KnownCommand t => SpecWith ()

module Test.Integration.Scenario.CLI.Mnemonics
spec :: forall t. KnownCommand t => SpecWith ()

module Test.Integration.Scenario.CLI.Network
spec :: forall t. KnownCommand t => SpecWith (Context t)

module Test.Integration.Scenario.CLI.Port
spec :: forall t s. (HasType (Port "wallet") s, KnownCommand t) => SpecWith s

module Test.Integration.Scenario.CLI.Transactions
spec :: forall t n. (n ~  'Testnet, KnownCommand t) => SpecWith (Context t)

module Test.Integration.Scenario.CLI.Wallets
spec :: forall t n. (n ~  'Testnet, KnownCommand t) => SpecWith (Context t)
